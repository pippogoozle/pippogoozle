<!DOCTYPE html>
<html lang="de">
<head>
<meta charset="UTF-8">
<title>Die Fliegenden Welten</title>
<style>
* { margin:0; padding:0; box-sizing:border-box; }
body { background:#000; overflow:hidden; font-family:'Segoe UI',sans-serif; }
canvas { display:block; }

#ui { position:fixed; top:0; left:0; width:100%; height:100%; pointer-events:none; z-index:10; }

#hud-top {
  position:absolute; top:20px; left:50%; transform:translateX(-50%);
  display:flex; gap:20px; align-items:center;
}
#game-title { color:#a8d8ff; font-size:20px; font-weight:200; letter-spacing:6px; text-shadow:0 0 20px #4af; }
#crystal-count { background:rgba(0,0,0,0.6); border:1px solid #4af; color:#4af; padding:8px 20px; border-radius:20px; font-size:18px; letter-spacing:2px; }

#crosshair { position:absolute; top:50%; left:50%; transform:translate(-50%,-50%); width:22px; height:22px; }
#crosshair::before,#crosshair::after { content:''; position:absolute; background:rgba(255,255,255,0.85); border-radius:2px; }
#crosshair::before { width:2px; height:100%; left:50%; transform:translateX(-50%); }
#crosshair::after { width:100%; height:2px; top:50%; transform:translateY(-50%); }

#interact-hint {
  position:absolute; bottom:130px; left:50%; transform:translateX(-50%);
  background:rgba(0,0,0,0.75); border:1px solid #4af; color:#fff;
  padding:10px 28px; border-radius:8px; font-size:16px; letter-spacing:1px;
  opacity:0; transition:opacity 0.3s;
}
#interact-hint.show { opacity:1; }



#controls { position:absolute; bottom:20px; left:20px; color:rgba(255,255,255,0.45); font-size:12px; line-height:2; }

#message {
  position:absolute; top:40%; left:50%; transform:translate(-50%,-50%);
  background:rgba(0,0,20,0.92); border:2px solid #4af; color:#a8d8ff;
  padding:24px 48px; border-radius:12px; font-size:20px; text-align:center;
  letter-spacing:2px; opacity:0; transition:opacity 0.5s; text-shadow:0 0 10px #4af;
}
#message.show { opacity:1; }

#start-screen {
  position:fixed; top:0; left:0; width:100%; height:100%;
  background:radial-gradient(ellipse at center, #000818 0%, #000008 100%);
  display:flex; flex-direction:column; align-items:center; justify-content:center;
  z-index:100;
}
#start-screen h1 { font-size:50px; font-weight:100; letter-spacing:14px; color:#a8d8ff; text-shadow:0 0 40px #4af,0 0 80px #26f; margin-bottom:16px; }
#start-screen p { font-size:16px; color:rgba(200,220,255,0.6); letter-spacing:3px; margin-bottom:48px; }
#start-btn { background:transparent; border:2px solid #4af; color:#4af; padding:15px 50px; font-size:17px; letter-spacing:5px; cursor:pointer; transition:all 0.3s; border-radius:4px; text-transform:uppercase; }
#start-btn:hover { background:rgba(68,170,255,0.15); box-shadow:0 0 30px #4af; }

#shop-screen {
  position:fixed; top:0; left:0; width:100%; height:100%;
  background:rgba(0,0,10,0.88);
  display:none; flex-direction:column; align-items:center; justify-content:center;
  z-index:50; pointer-events:all;
}
#shop-screen h2 { font-size:32px; font-weight:100; letter-spacing:10px; color:#ffd700; text-shadow:0 0 30px #fa0; margin-bottom:12px; }
#shop-screen p { color:rgba(255,220,150,0.7); font-size:15px; letter-spacing:2px; margin-bottom:36px; }
.shop-item { background:rgba(0,0,20,0.9); border:2px solid #fa0; border-radius:10px; padding:20px 40px; margin:10px; cursor:pointer; transition:all 0.3s; text-align:center; }
.shop-item:hover { background:rgba(255,160,0,0.15); box-shadow:0 0 24px #fa0; }
.shop-item h3 { color:#ffd700; font-size:20px; letter-spacing:3px; margin-bottom:6px; }
.shop-item .cost { color:#4af; font-size:14px; letter-spacing:2px; }
.shop-item.disabled { opacity:0.4; cursor:not-allowed; border-color:#555; }
.shop-item.disabled:hover { background:none; box-shadow:none; }
#shop-close { margin-top:24px; background:transparent; border:1px solid rgba(255,255,255,0.3); color:rgba(255,255,255,0.5); padding:10px 30px; border-radius:6px; cursor:pointer; font-size:14px; letter-spacing:3px; }
#shop-close:hover { border-color:#fff; color:#fff; }
</style>
</head>
<body>

<div id="start-screen">
  <h1>DIE FLIEGENDEN WELTEN</h1>
  <p>LÃ¶se RÃ¤tsel Â· Sammle Kristalle Â· Erkunde alle Inseln</p>
  <button id="start-btn">Spiel Starten</button>
</div>

<div id="shop-screen">
  <h2>âœ¦ SHOP âœ¦</h2>
  <p>Gib deine Kristalle aus</p>
  <div class="shop-item" id="shop-color" onclick="buyColor()">
    <h3>ðŸŒˆ COLOR WORLD</h3>
    <div class="cost">ðŸ’Ž 10 Kristalle</div>
  </div>
  <button id="shop-close" onclick="closeShop()">SCHLIESSEN</button>
</div>

<canvas id="canvas"></canvas>

<div id="ui">
  <div id="hud-top">
    <div id="game-title">DIE FLIEGENDEN WELTEN</div>
    <div id="crystal-count">ðŸ’Ž <span id="c-count">0</span></div>
  </div>
  <div id="crosshair"></div>
  <div id="interact-hint">[ E ] Interagieren</div>
  <div id="controls">
    WASD â€” Bewegen &nbsp;|&nbsp; Maus â€” Umsehen<br>
    Leertaste â€” Springen &nbsp;|&nbsp; E â€” Interagieren
  </div>
  <div id="message"></div>
</div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<script>
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// RENDERER
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const canvas = document.getElementById('canvas');
const renderer = new THREE.WebGLRenderer({ canvas, antialias:true });
renderer.setSize(innerWidth, innerHeight);
renderer.setPixelRatio(Math.min(devicePixelRatio, 2));
renderer.shadowMap.enabled = true;
renderer.shadowMap.type = THREE.PCFSoftShadowMap;
renderer.setClearColor(0x020812);

const scene = new THREE.Scene();
scene.fog = new THREE.FogExp2(0x020818, 0.006);

const camera = new THREE.PerspectiveCamera(75, innerWidth/innerHeight, 0.1, 2000);

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// LIGHTING
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
scene.add(new THREE.AmbientLight(0x102040, 1.2));

const sun = new THREE.DirectionalLight(0xffe0b0, 1.8);
sun.position.set(150, 300, 100);
sun.castShadow = true;
sun.shadow.camera.far = 1200;
sun.shadow.camera.left = sun.shadow.camera.bottom = -300;
sun.shadow.camera.right = sun.shadow.camera.top = 300;
sun.shadow.mapSize.set(2048, 2048);
scene.add(sun);

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// SKY + STARS
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const skyMesh = new THREE.Mesh(
  new THREE.SphereGeometry(1400,32,32),
  new THREE.MeshBasicMaterial({ color:0x010612, side:THREE.BackSide })
);
scene.add(skyMesh);

const starGeo = new THREE.BufferGeometry();
const starPos = new Float32Array(5000*3);
for(let i=0;i<starPos.length;i++) starPos[i]=(Math.random()-.5)*2600;
starGeo.setAttribute('position', new THREE.BufferAttribute(starPos,3));
scene.add(new THREE.Points(starGeo, new THREE.PointsMaterial({color:0xffffff,size:1.2,sizeAttenuation:true})));

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// MATERIALS
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const mats = {
  grass:  (hue)=>new THREE.MeshLambertMaterial({color:new THREE.Color().setHSL(hue,0.5,0.28)}),
  rock:   ()=>new THREE.MeshLambertMaterial({color:0x554433}),
  wood:   ()=>new THREE.MeshLambertMaterial({color:0x5a3800}),
  leaf:   ()=>new THREE.MeshLambertMaterial({color:0x1a5a1a}),
  bridge: ()=>new THREE.MeshLambertMaterial({color:0x7a5a30}),
  rope:   ()=>new THREE.MeshBasicMaterial({color:0x886633}),
  crystal:  new THREE.MeshPhongMaterial({color:0x00ccff,emissive:0x0055aa,emissiveIntensity:0.6,transparent:true,opacity:0.88,shininess:220}),
};

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// ISLAND DATA
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
let _seed = Math.floor(Math.random()*99999);
function rng() { _seed = (_seed * 1664525 + 1013904223) & 0xffffffff; return ((_seed >>> 0) / 0xffffffff); }
function rngRange(a,b){ return a + rng()*(b-a); }
function rngInt(a,b){ return Math.floor(rngRange(a,b+1)); }

const ISLANDS = [
  { id:0,  x:   0, y:  0, z:   0, r:20 },
  { id:1,  x:  90, y:  8, z:   0, r:14 },
  { id:2,  x: -90, y: 12, z:   0, r:14 },
  { id:3,  x:   0, y: 16, z:  90, r:14 },
  { id:4,  x:   0, y:  4, z: -90, r:14 },
  { id:5,  x: 180, y: 20, z:   0, r:12 },
  { id:6,  x:-180, y:  6, z:  60, r:12 },
  { id:7,  x:  80, y: 30, z: 130, r:12 },
  { id:8,  x: -80, y: -8, z:-130, r:12 },
  { id:9,  x: 260, y: 14, z:  80, r:11 },
  { id:10, x:-240, y: 22, z: -80, r:11 },
  { id:11, x: 340, y:  5, z:-100, r:12 },
  { id:12, x:-300, y: 28, z: 180, r:11 },
  { id:13, x: 150, y: 38, z: 260, r:13 },
  { id:14, x:-160, y:-12, z:-260, r:11 },
];

const BRIDGES = [
  [0,1],[0,2],[0,3],[0,4],
  [1,5],[2,6],[3,7],[4,8],
  [5,9],[6,10],[9,11],[10,12],[7,13],[8,14],
];

const islandMeshes = [];
const interactables = [];
const allCrystals = [];
const puzzles = [];

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// BUILD ISLANDS
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function buildIsland(cfg) {
  const g = new THREE.Group();
  g.position.set(cfg.x, cfg.y, cfg.z);
  g.userData = { ...cfg, originalY: cfg.y };

  const body = new THREE.Mesh(
    new THREE.CylinderGeometry(cfg.r*0.65, cfg.r, cfg.r*0.35, 14),
    mats.grass(0.25 + (cfg.id%7)*0.035)
  );
  body.receiveShadow = body.castShadow = true;
  g.add(body);

  const rock = new THREE.Mesh(
    new THREE.ConeGeometry(cfg.r*0.72, cfg.r*0.85, 11),
    mats.rock()
  );
  rock.position.y = -cfg.r*0.6;
  rock.castShadow = true;
  g.add(rock);

  for(let i=0;i<6+cfg.id%4;i++){
    const angle = i/6*Math.PI*2 + cfg.id;
    const rad = rng()*cfg.r*0.45;
    const isRock = rng()>0.6;
    const bm = new THREE.Mesh(
      isRock ? new THREE.DodecahedronGeometry(0.6+rng()*1.5,0)
             : new THREE.SphereGeometry(0.4+rng(),7,7),
      isRock ? mats.rock() : mats.grass(0.3+rng()*0.05)
    );
    bm.position.set(Math.cos(angle)*rad, cfg.r*0.18+rng()*1.5, Math.sin(angle)*rad);
    bm.castShadow = true;
    g.add(bm);
  }

  const treeCount = 2 + cfg.id%4;
  for(let t=0;t<treeCount;t++){
    const angle = t/treeCount*Math.PI*2 + cfg.id*0.7;
    const rad = 2 + rng()*cfg.r*0.4;
    addTree(g, Math.cos(angle)*rad, Math.sin(angle)*rad);
  }

  g.userData.topY = cfg.y + cfg.r*0.19;
  scene.add(g);
  islandMeshes.push(g);
  return g;
}

function addTree(parent, lx, lz) {
  const trunk = new THREE.Mesh(new THREE.CylinderGeometry(0.22,0.32,2.8,6), mats.wood());
  trunk.position.set(lx, 1.4, lz);
  trunk.castShadow = true;
  parent.add(trunk);
  for(let i=0;i<3;i++){
    const cone = new THREE.Mesh(new THREE.ConeGeometry(1.6-i*0.3,1.6,8), mats.leaf());
    cone.position.set(lx, 3.0+i*1.1, lz);
    cone.castShadow = true;
    parent.add(cone);
  }
}

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// BUILD BRIDGES
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const bridgeSegments = [];

function buildBridge(idA, idB) {
  const a = ISLANDS[idA], b = ISLANDS[idB];
  const posA = new THREE.Vector3(a.x, a.y + a.r*0.19, a.z);
  const posB = new THREE.Vector3(b.x, b.y + b.r*0.19, b.z);

  const dir  = posB.clone().sub(posA);
  const length = dir.length();
  const angle  = Math.atan2(dir.x, dir.z);
  const BRIDGE_W = 3.0;
  const SEGS = Math.max(12, Math.floor(length / 4));

  for(let i = 0; i < SEGS; i++){
    const t0 = i / SEGS;
    const t1 = (i+1) / SEGS;
    const tm = (t0+t1)*0.5;

    const sag = (cfg) => Math.sin(cfg * Math.PI) * length * 0.05;

    const p0x = posA.x + dir.x*t0,  p0z = posA.z + dir.z*t0;
    const p0y = posA.y + (posB.y-posA.y)*t0 - sag(t0);
    const p1x = posA.x + dir.x*t1,  p1z = posA.z + dir.z*t1;
    const p1y = posA.y + (posB.y-posA.y)*t1 - sag(t1);
    const pmx = posA.x + dir.x*tm,  pmz = posA.z + dir.z*tm;
    const pmy = posA.y + (posB.y-posA.y)*tm - sag(tm);

    const segLen = Math.sqrt((p1x-p0x)**2 + (p1y-p0y)**2 + (p1z-p0z)**2) + 0.02;

    const dx = p1x-p0x, dy = p1y-p0y, dz = p1z-p0z;
    const horizLen = Math.sqrt(dx*dx+dz*dz);
    const pitch = -Math.atan2(dy, horizLen);

    const seg = new THREE.Mesh(
      new THREE.BoxGeometry(BRIDGE_W, 0.22, segLen),
      mats.bridge()
    );
    seg.position.set(pmx, pmy, pmz);
    seg.rotation.order = 'YXZ';
    seg.rotation.y = angle;
    seg.rotation.x = pitch;
    seg.castShadow = true;
    seg.receiveShadow = true;
    scene.add(seg);

    bridgeSegments.push({
      mesh: seg,
      cx: pmx, cy: pmy, cz: pmz,
      angle, pitch,
      halfLen: segLen*0.5,
      halfW: BRIDGE_W*0.5
    });

    if(i % 4 === 0){
      for(let s=-1;s<=1;s+=2){
        const offX = Math.cos(angle + Math.PI/2) * s * (BRIDGE_W*0.5 - 0.15);
        const offZ = Math.sin(angle + Math.PI/2) * s * (BRIDGE_W*0.5 - 0.15);
        const post = new THREE.Mesh(
          new THREE.CylinderGeometry(0.08, 0.08, 1.5, 5),
          new THREE.MeshBasicMaterial({color:0x886633})
        );
        post.position.set(pmx + offX, pmy + 0.75, pmz + offZ);
        scene.add(post);
      }
    }
  }

  for(let s=-1;s<=1;s+=2){
    const mid = posA.clone().add(posB).multiplyScalar(0.5);
    const midSag = posA.y + (posB.y-posA.y)*0.5 - length*0.05*1.0;
    const offX = Math.cos(angle + Math.PI/2) * s * (BRIDGE_W*0.5 - 0.15);
    const offZ = Math.sin(angle + Math.PI/2) * s * (BRIDGE_W*0.5 - 0.15);

    for(let half=0;half<2;half++){
      const hA = half===0 ? posA : mid.clone().setY(midSag+0.9);
      const hB = half===0 ? mid.clone().setY(midSag+0.9) : posB;
      const hDir = hB.clone().sub(hA);
      const hLen = hDir.length();
      const hAngle = Math.atan2(hDir.x, hDir.z);
      const hDy = hDir.y;
      const hHoriz = Math.sqrt(hDir.x**2+hDir.z**2);
      const hPitch = -Math.atan2(hDy, hHoriz);
      const hMid = hA.clone().add(hB).multiplyScalar(0.5);

      const rope = new THREE.Mesh(
        new THREE.BoxGeometry(0.08, 0.08, hLen),
        new THREE.MeshBasicMaterial({color:0x886633})
      );
      rope.position.set(hMid.x+offX, hMid.y+0.9, hMid.z+offZ);
      rope.rotation.order='YXZ';
      rope.rotation.y = hAngle;
      rope.rotation.x = hPitch;
      scene.add(rope);
    }
  }
}

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// PUZZLE OBJECTS â€” each has its own material instance
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function addLever(islandGroup, lx, lz) {
  const g = new THREE.Group();
  g.position.set(lx, islandGroup.userData.r*0.19, lz);

  const base = new THREE.Mesh(new THREE.BoxGeometry(0.7,0.35,0.7), new THREE.MeshLambertMaterial({color:0x888888}));
  g.add(base);

  // Each lever gets its OWN material so color changes don't affect others
  const stickMat = new THREE.MeshPhongMaterial({color:0x888888, emissive:0x000000});
  const stick = new THREE.Mesh(new THREE.CylinderGeometry(0.1,0.1,1.3,6), stickMat);
  stick.position.y = 0.85;
  stick.rotation.z = 0.65;
  g.add(stick);

  islandGroup.add(g);
  const localPos = new THREE.Vector3(lx, islandGroup.userData.r*0.19, lz);
  const obj = {
    type:'lever', group:g, stick, stickMat, islandGroup, state:false,
    worldPos:()=>{
      const wp = new THREE.Vector3();
      islandGroup.localToWorld(wp.copy(localPos));
      return wp;
    }
  };
  interactables.push(obj);
  return obj;
}

function addButton(islandGroup, lx, lz) {
  const g = new THREE.Group();
  g.position.set(lx, islandGroup.userData.r*0.19, lz);

  const base = new THREE.Mesh(new THREE.CylinderGeometry(0.45,0.45,0.22,12), new THREE.MeshLambertMaterial({color:0x555555}));
  g.add(base);

  // Own material
  const btnMat = new THREE.MeshPhongMaterial({color:0xff2222, emissive:0x440000});
  const btn = new THREE.Mesh(new THREE.CylinderGeometry(0.32,0.32,0.18,12), btnMat);
  btn.position.y = 0.2;
  g.add(btn);

  islandGroup.add(g);
  const localPos = new THREE.Vector3(lx, islandGroup.userData.r*0.19, lz);
  const obj = {
    type:'button', group:g, btn, btnMat, islandGroup, state:false,
    worldPos:()=>{
      const wp = new THREE.Vector3();
      islandGroup.localToWorld(wp.copy(localPos));
      return wp;
    }
  };
  interactables.push(obj);
  return obj;
}

function addPressurePlate(islandGroup, lx, lz) {
  const g = new THREE.Group();
  g.position.set(lx, islandGroup.userData.r*0.19, lz);

  // Own material
  const plateMat = new THREE.MeshPhongMaterial({color:0xddaa00, emissive:0x332200});
  const plate = new THREE.Mesh(new THREE.BoxGeometry(1.4,0.12,1.4), plateMat);
  g.add(plate);

  islandGroup.add(g);
  const localPos = new THREE.Vector3(lx, islandGroup.userData.r*0.19, lz);
  const obj = {
    type:'pressure', group:g, plate, plateMat, islandGroup, state:false,
    worldPos:()=>{
      const wp = new THREE.Vector3();
      islandGroup.localToWorld(wp.copy(localPos));
      return wp;
    }
  };
  interactables.push(obj);
  return obj;
}

function addCrystal(x, y, z, puzzleId) {
  const g = new THREE.Group();
  g.position.set(x, y, z);

  const mesh = new THREE.Mesh(new THREE.OctahedronGeometry(0.75,0), mats.crystal.clone());
  mesh.castShadow = true;
  g.add(mesh);

  const glow = new THREE.Mesh(new THREE.SphereGeometry(1.0,8,8), new THREE.MeshBasicMaterial({color:0x0088ff,transparent:true,opacity:0.12}));
  g.add(glow);

  const light = new THREE.PointLight(0x0099ff, 1.5, 10);
  g.add(light);

  g.userData = { isCrystal:true, collected:false, puzzleId };
  g.visible = false;
  scene.add(g);
  allCrystals.push(g);
  return g;
}

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// PUZZLE SYSTEM â€” fixed with proper state resets
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
class Puzzle {
  constructor(islandId, steps) {
    this.islandId = islandId;
    this.steps = steps; // correct order
    this.progress = 0;
    this.solved = false;
    this.reward = null;
    this.history = [];
    this.id = puzzles.length;
    puzzles.push(this);
  }

  setVisual(obj, activated) {
    if(obj.type === 'lever') {
      obj.stick.rotation.z = activated ? -0.65 : 0.65;
      obj.stickMat.color.setHex(activated ? 0x00ff88 : 0x888888);
      obj.stickMat.emissive.setHex(activated ? 0x005522 : 0x000000);
    } else if(obj.type === 'button') {
      obj.btnMat.color.setHex(activated ? 0x00ff22 : 0xff2222);
      obj.btnMat.emissive.setHex(activated ? 0x004400 : 0x440000);
    } else if(obj.type === 'pressure') {
      obj.plateMat.color.setHex(activated ? 0x00ff88 : 0xddaa00);
      obj.plateMat.emissive.setHex(activated ? 0x004400 : 0x332200);
    }
  }

  reset() {
    this.progress = 0;
    this.history = [];
    for(const s of this.steps) {
      s.state = false;
      this.setVisual(s, false);
    }
  }

  tryActivate(obj) {
    if(this.solved) return;

    // All objects toggle on/off
    obj.state = !obj.state;
    this.setVisual(obj, obj.state);

    if(!obj.state) {
      // Deactivated â€” remove last occurrence from history
      const idx = this.history.lastIndexOf(obj);
      if(idx !== -1) this.history.splice(idx, 1);
      return;
    }

    // Activated â€” add to history
    this.history.push(obj);

    // Check if the last N activations match the required sequence
    const n = this.steps.length;
    if(this.history.length >= n) {
      const last = this.history.slice(-n);
      const match = last.every((o, i) => o === this.steps[i]);
      if(match) {
        this.solved = true;
        this.reward.visible = true;
        this.reward.children[2].intensity = 3;
        showMessage('ðŸ’Ž');
      }
    }
  }
}

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// BUILD WORLD
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
ISLANDS.forEach(cfg => buildIsland(cfg));
BRIDGES.forEach(([a,b]) => buildBridge(a,b));

function generateRandomPuzzle(island, r) {
  const usedPositions = [];

  function randPos() {
    let tries = 0;
    while(tries++ < 20) {
      const angle = rng() * Math.PI * 2;
      const dist  = r * (0.15 + rng() * 0.32);
      const lx = Math.cos(angle) * dist;
      const lz = Math.sin(angle) * dist;
      if(!usedPositions.some(p => Math.hypot(p[0]-lx, p[1]-lz) < 3.5)) {
        usedPositions.push([lx,lz]);
        return [lx,lz];
      }
    }
    const lx = rngRange(-r*0.3, r*0.3), lz = rngRange(-r*0.3, r*0.3);
    usedPositions.push([lx,lz]);
    return [lx,lz];
  }

  // Determine count and positions first
  const count = rngInt(2, 4);
  const positions = [];
  for(let i=0; i<count; i++) positions.push(randPos());

  // Determine random order (the correct puzzle sequence)
  const orderIndices = Array.from({length:count}, (_,i)=>i);
  for(let i=orderIndices.length-1;i>0;i--){
    const j = rngInt(0,i);
    [orderIndices[i],orderIndices[j]] = [orderIndices[j],orderIndices[i]];
  }

  // Create objects without any labels
  const objects = new Array(count);
  for(let i=0; i<count; i++){
    const [lx,lz] = positions[i];
    const t = rngInt(0,2);
    if(t===0) objects[i] = addLever(island, lx, lz);
    else if(t===1) objects[i] = addButton(island, lx, lz);
    else objects[i] = addPressurePlate(island, lx, lz);
  }

  // Build steps array in correct activation order
  const steps = orderIndices.map(i => objects[i]);
  return steps;
}

function setupPuzzles() {
  ISLANDS.forEach((cfg, i) => {
    if(i === 0) return;
    const island = islandMeshes[i];
    const r = cfg.r;

    const steps = generateRandomPuzzle(island, r);
    const crystal = addCrystal(cfg.x, cfg.y + r*0.19 + 2.5, cfg.z, i);
    const puz = new Puzzle(i, steps);
    puz.reward = crystal;
    steps.forEach(s => s.puzzle = puz);
  });
}

setupPuzzles();

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// SHOP NPC on hub island
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
let colorWorldActive = false;
const allIslandMeshRefs = []; // store body meshes for recoloring
const allBridgeMeshRefs = []; // store bridge segment meshes

// Collect island body meshes (child 0 = body cylinder)
islandMeshes.forEach(isl => allIslandMeshRefs.push(isl.children[0]));
// Collect bridge segment meshes
bridgeSegments.forEach(seg => allBridgeMeshRefs.push(seg.mesh));

// NPC â€” glowing chest on hub island
const hubIsland = islandMeshes[0];
const npcGroup = new THREE.Group();
npcGroup.position.set(4, ISLANDS[0].r*0.19, 0);

const chestBase = new THREE.Mesh(
  new THREE.BoxGeometry(1.2, 0.8, 0.9),
  new THREE.MeshPhongMaterial({color:0xaa7700, emissive:0x332200})
);
npcGroup.add(chestBase);

const chestLid = new THREE.Mesh(
  new THREE.BoxGeometry(1.2, 0.4, 0.9),
  new THREE.MeshPhongMaterial({color:0xcc9900, emissive:0x443300})
);
chestLid.position.y = 0.6;
npcGroup.add(chestLid);

const chestGlow = new THREE.Mesh(
  new THREE.SphereGeometry(1.0, 8, 8),
  new THREE.MeshBasicMaterial({color:0xffaa00, transparent:true, opacity:0.10})
);
npcGroup.add(chestGlow);

const chestLight = new THREE.PointLight(0xffaa00, 1.2, 8);
npcGroup.add(chestLight);

hubIsland.add(npcGroup);

const shopNPC = {
  type: 'shop',
  worldPos: () => {
    const wp = new THREE.Vector3();
    hubIsland.localToWorld(wp.copy(new THREE.Vector3(4, ISLANDS[0].r*0.19, 0)));
    return wp;
  }
};
interactables.push(shopNPC);

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// SHOP LOGIC
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
let shopOpen = false;

function openShop() {
  shopOpen = true;
  document.exitPointerLock();
  const shopEl = document.getElementById('shop-screen');
  shopEl.style.display = 'flex';
  // Update affordability
  const colorBtn = document.getElementById('shop-color');
  if(player.collected < 10 || colorWorldActive) {
    colorBtn.classList.add('disabled');
    colorBtn.querySelector('.cost').textContent = colorWorldActive ? 'âœ“ Gekauft' : 'ðŸ’Ž 10 Kristalle';
  } else {
    colorBtn.classList.remove('disabled');
  }
}

function closeShop() {
  shopOpen = false;
  document.getElementById('shop-screen').style.display = 'none';
  canvas.requestPointerLock();
}

function buyColor() {
  if(player.collected < 10 || colorWorldActive) return;
  player.collected -= 10;
  document.getElementById('c-count').textContent = player.collected;
  colorWorldActive = true;
  applyColorWorld();
  closeShop();
  showMessage('ðŸŒˆ Color World freigeschaltet!');
}

function applyColorWorld() {
  // Random color for each island body
  allIslandMeshRefs.forEach(mesh => {
    mesh.material = new THREE.MeshLambertMaterial({
      color: new THREE.Color().setHSL(Math.random(), 0.7, 0.45)
    });
  });
  // Random color for each bridge segment
  allBridgeMeshRefs.forEach(mesh => {
    mesh.material = new THREE.MeshLambertMaterial({
      color: new THREE.Color().setHSL(Math.random(), 0.8, 0.5)
    });
  });
}

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// PLAYER
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const player = {
  pos: new THREE.Vector3(0, 6, 0),
  vel: new THREE.Vector3(),
  yaw: 0,
  pitch: 0,
  onGround: false,
  collected: 0
};

const keys = {};
window.addEventListener('keydown', e=>{
  keys[e.code]=true;
  if(e.code==='KeyE') interact();
  if(e.code==='Space') e.preventDefault();
});
window.addEventListener('keyup', e=>{ keys[e.code]=false; });

document.getElementById('start-btn').addEventListener('click', ()=>{
  document.getElementById('start-screen').style.display='none';
  canvas.requestPointerLock();
});
canvas.addEventListener('click', ()=>{ if(document.pointerLockElement!==canvas) canvas.requestPointerLock(); });
window.addEventListener('mousemove', e=>{
  if(document.pointerLockElement!==canvas) return;
  player.yaw   -= e.movementX * 0.002;
  player.pitch -= e.movementY * 0.002;
  player.pitch  = Math.max(-1.3, Math.min(1.3, player.pitch));
});

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// INTERACTION
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function interact() {
  const RANGE = 5;

  // Crystals
  for(const c of allCrystals){
    if(!c.visible || c.userData.collected) continue;
    if(player.pos.distanceTo(c.position) < RANGE-1) {
      c.userData.collected = true;
      c.visible = false;
      player.collected++;
      document.getElementById('c-count').textContent = player.collected;
      showMessage('ðŸ’Ž ' + player.collected);
      return;
    }
  }

  // Find nearest interactable
  let nearest = null, nearDist = RANGE;
  for(const obj of interactables){
    const d = player.pos.distanceTo(obj.worldPos());
    if(d < nearDist){ nearDist=d; nearest=obj; }
  }
  if(!nearest) return;

  if(nearest.type === 'shop') {
    openShop();
    return;
  }
  if(nearest.type === 'lever') {
    nearest.puzzle?.tryActivate(nearest);
  }
  else if(nearest.type === 'button') {
    nearest.puzzle?.tryActivate(nearest);
  }
  else if(nearest.type === 'pressure') {
    nearest.puzzle?.tryActivate(nearest);
  }
}

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// PHYSICS
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const GRAVITY = -28;
const SPEED   = 13;
const JUMP    = 16;

function physics(dt) {
  const moveDir = new THREE.Vector3();
  if(keys['KeyW']) moveDir.z -= 1;
  if(keys['KeyS']) moveDir.z += 1;
  if(keys['KeyA']) moveDir.x -= 1;
  if(keys['KeyD']) moveDir.x += 1;
  if(moveDir.length() > 0) moveDir.normalize();

  const cos = Math.cos(player.yaw), sin = Math.sin(player.yaw);
  player.vel.x = (moveDir.x*cos + moveDir.z*sin) * SPEED;
  player.vel.z = (-moveDir.x*sin + moveDir.z*cos) * SPEED;
  player.vel.y += GRAVITY * dt;

  player.pos.addScaledVector(player.vel, dt);

  player.onGround = false;
  for(const isl of islandMeshes) {
    const d = ISLANDS[isl.userData.id];
    const topY = isl.position.y + d.r*0.19 + 1.7;
    const dx = player.pos.x - isl.position.x;
    const dz = player.pos.z - isl.position.z;
    const dist = Math.sqrt(dx*dx+dz*dz);
    if(dist < d.r*0.82 && player.pos.y < topY+0.5 && player.pos.y > topY-4 && player.vel.y<=0){
      player.pos.y = topY;
      player.vel.y = 0;
      player.onGround = true;
      break;
    }
  }

  if(!player.onGround && player.vel.y <= 0) {
    for(const seg of bridgeSegments) {
      const dx = player.pos.x - seg.cx;
      const dz = player.pos.z - seg.cz;
      const cosA = Math.cos(-seg.angle), sinA = Math.sin(-seg.angle);
      const lx =  dx*cosA + dz*sinA;
      const lz = -dx*sinA + dz*cosA;
      if(Math.abs(lx) < seg.halfW * 0.95 && Math.abs(lz) < seg.halfLen + 0.3) {
        const surfY = seg.cy + Math.tan(-seg.pitch) * lz + 0.11 + 1.7;
        if(player.pos.y < surfY + 0.5 && player.pos.y > surfY - 3.5) {
          player.pos.y = surfY;
          player.vel.y = 0;
          player.onGround = true;
          break;
        }
      }
    }
  }

  if(keys['Space'] && player.onGround){
    player.vel.y = JUMP;
    player.onGround = false;
  }

  if(player.pos.y < -180){
    player.pos.set(0,8,0);
    player.vel.set(0,0,0);
    showMessage('ðŸ’€ Gefallen! ZurÃ¼ck zur Hub-Insel.');
  }
}

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// INTERACT HINT + PUZZLE HINT
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const hintEl = document.getElementById('interact-hint');

function updateHint() {
  const RANGE = 5;
  let nearObj = null;
  let nearCrystal = false;

  for(const obj of interactables){
    if(player.pos.distanceTo(obj.worldPos()) < RANGE){
      nearObj = obj;
      break;
    }
  }

  if(!nearObj) {
    for(const c of allCrystals){
      if(c.visible && !c.userData.collected && player.pos.distanceTo(c.position) < RANGE-1){
        nearCrystal = true; break;
      }
    }
  }

  if(nearObj) {
    hintEl.className = 'show';
    if(nearObj.type==='lever') hintEl.textContent = '[ E ]  Hebel betÃ¤tigen';
    else if(nearObj.type==='button') hintEl.textContent = '[ E ]  Knopf drÃ¼cken';
    else if(nearObj.type==='pressure') hintEl.textContent = '[ E ]  Druckplatte aktivieren';
    else if(nearObj.type==='shop') hintEl.textContent = '[ E ]  Shop Ã¶ffnen';
  } else if(nearCrystal) {
    hintEl.className = 'show';
    hintEl.textContent = '[ E ]  Kristall aufsammeln';
  } else {
    hintEl.className = '';
  }
}

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// MESSAGE
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
let msgTimer;
function showMessage(txt) {
  const el = document.getElementById('message');
  el.textContent = txt;
  el.className = 'show';
  clearTimeout(msgTimer);
  msgTimer = setTimeout(()=>el.className='', 3500);
}

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// GAME LOOP
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
let prev = performance.now();

function loop(now) {
  requestAnimationFrame(loop);
  const dt = Math.min((now-prev)/1000, 0.05);
  prev = now;
  const t = now/1000;

  physics(dt);

  // Floating islands
  for(const isl of islandMeshes){
    isl.position.y = isl.userData.originalY + Math.sin(t*0.35 + isl.userData.id*0.9) * 1.2;
  }

  // Animate crystals
  for(const c of allCrystals){
    if(!c.visible) continue;
    c.children[0].rotation.y += dt*1.8;
    c.children[0].position.y = Math.sin(t*2.2 + c.userData.puzzleId)*0.25;
  }

  // Animate shop chest glow
  if(chestGlow) {
    chestGlow.material.opacity = 0.08 + Math.sin(t*2.5)*0.06;
    chestLight.intensity = 1.0 + Math.sin(t*2.5)*0.4;
    chestLid.rotation.z = Math.sin(t*1.5)*0.08;
  }

  camera.position.copy(player.pos);
  camera.rotation.order = 'YXZ';
  camera.rotation.y = player.yaw;
  camera.rotation.x = player.pitch;

  updateHint();
  renderer.render(scene, camera);
}

window.addEventListener('resize', ()=>{
  camera.aspect = innerWidth/innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(innerWidth, innerHeight);
});

requestAnimationFrame(loop);
</script>
</body>
</html>
