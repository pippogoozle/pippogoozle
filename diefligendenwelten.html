<!DOCTYPE html>
<html lang="de">
<head>
<meta charset="UTF-8">
<title>Die Fliegenden Welten</title>
<style>
* { margin:0; padding:0; box-sizing:border-box; }
body { background:#000; overflow:hidden; font-family:'Segoe UI',sans-serif; }
canvas { display:block; }
#ui { position:fixed; top:0; left:0; width:100%; height:100%; pointer-events:none; z-index:10; }
#hud-top { position:absolute; top:20px; left:50%; transform:translateX(-50%); display:flex; gap:20px; align-items:center; }
#game-title { color:#a8d8ff; font-size:20px; font-weight:200; letter-spacing:6px; text-shadow:0 0 20px #4af; }
#crystal-count { background:rgba(0,0,0,0.6); border:1px solid #4af; color:#4af; padding:8px 20px; border-radius:20px; font-size:18px; letter-spacing:2px; }
#crosshair { position:absolute; top:50%; left:50%; transform:translate(-50%,-50%); width:22px; height:22px; }
#crosshair::before,#crosshair::after { content:''; position:absolute; background:rgba(255,255,255,0.85); border-radius:2px; }
#crosshair::before { width:2px; height:100%; left:50%; transform:translateX(-50%); }
#crosshair::after { width:100%; height:2px; top:50%; transform:translateY(-50%); }
#interact-hint { position:absolute; bottom:130px; left:50%; transform:translateX(-50%); background:rgba(0,0,0,0.75); border:1px solid #4af; color:#fff; padding:10px 28px; border-radius:8px; font-size:16px; letter-spacing:1px; opacity:0; transition:opacity 0.3s; }
#interact-hint.show { opacity:1; }
#controls { position:absolute; bottom:20px; left:20px; color:rgba(255,255,255,0.45); font-size:12px; line-height:2; }
#message { position:absolute; top:40%; left:50%; transform:translate(-50%,-50%); background:rgba(0,0,20,0.92); border:2px solid #4af; color:#a8d8ff; padding:24px 48px; border-radius:12px; font-size:20px; text-align:center; letter-spacing:2px; opacity:0; transition:opacity 0.5s; text-shadow:0 0 10px #4af; }
#message.show { opacity:1; }
#start-screen { position:fixed; top:0; left:0; width:100%; height:100%; background:radial-gradient(ellipse at center,#000818 0%,#000008 100%); display:flex; flex-direction:column; align-items:center; justify-content:center; z-index:100; }
#start-screen h1 { font-size:50px; font-weight:100; letter-spacing:14px; color:#a8d8ff; text-shadow:0 0 40px #4af,0 0 80px #26f; margin-bottom:16px; }
#start-screen p { font-size:16px; color:rgba(200,220,255,0.6); letter-spacing:3px; margin-bottom:48px; }
#start-btn { background:transparent; border:2px solid #4af; color:#4af; padding:15px 50px; font-size:17px; letter-spacing:5px; cursor:pointer; transition:all 0.3s; border-radius:4px; text-transform:uppercase; }
#start-btn:hover { background:rgba(68,170,255,0.15); box-shadow:0 0 30px #4af; }
#shop-screen { position:fixed; top:0; left:0; width:100%; height:100%; background:rgba(0,0,10,0.88); display:none; flex-direction:column; align-items:center; justify-content:center; z-index:50; pointer-events:all; }
#shop-screen h2 { font-size:32px; font-weight:100; letter-spacing:10px; color:#ffd700; text-shadow:0 0 30px #fa0; margin-bottom:12px; }
#shop-screen p { color:rgba(255,220,150,0.7); font-size:15px; letter-spacing:2px; margin-bottom:36px; }
.shop-item { background:rgba(0,0,20,0.9); border:2px solid #fa0; border-radius:10px; padding:20px 40px; margin:10px; cursor:pointer; transition:all 0.3s; text-align:center; }
.shop-item:hover { background:rgba(255,160,0,0.15); box-shadow:0 0 24px #fa0; }
.shop-item h3 { color:#ffd700; font-size:20px; letter-spacing:3px; margin-bottom:6px; }
.shop-item .cost { color:#4af; font-size:14px; letter-spacing:2px; }
.shop-item.disabled { opacity:0.4; cursor:not-allowed; border-color:#555; }
.shop-item.disabled:hover { background:none; box-shadow:none; }
#shop-close { margin-top:24px; background:transparent; border:1px solid rgba(255,255,255,0.3); color:rgba(255,255,255,0.5); padding:10px 30px; border-radius:6px; cursor:pointer; font-size:14px; letter-spacing:3px; }
#shop-close:hover { border-color:#fff; color:#fff; }
</style>
</head>
<body>
<div id="start-screen">
  <h1>DIE FLIEGENDEN WELTEN</h1>
  <p>LÃ¶se RÃ¤tsel Â· Sammle Kristalle Â· Erkunde unendlich viele Inseln</p>
  <button id="start-btn">Spiel Starten</button>
</div>
<div id="shop-screen">
  <h2>âœ¦ SHOP âœ¦</h2>
  <p>Gib deine Kristalle aus</p>
  <div class="shop-item" id="shop-color" onclick="buyColor()">
    <h3>ðŸŒˆ COLOR WORLD</h3>
    <div class="cost">ðŸ’Ž 10 Kristalle</div>
  </div>
  <button id="shop-close" onclick="closeShop()">SCHLIESSEN</button>
</div>
<canvas id="canvas"></canvas>
<div id="ui">
  <div id="hud-top">
    <div id="game-title">DIE FLIEGENDEN WELTEN</div>
    <div id="crystal-count">ðŸ’Ž <span id="c-count">0</span></div>
  </div>
  <div id="crosshair"></div>
  <div id="interact-hint">[ E ] Interagieren</div>
  <div id="controls">WASD â€” Bewegen &nbsp;|&nbsp; Maus â€” Umsehen<br>Leertaste â€” Springen &nbsp;|&nbsp; E â€” Interagieren</div>
  <div id="message"></div>
</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<script>
// â”€â”€ RENDERER â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const canvas = document.getElementById('canvas');
const renderer = new THREE.WebGLRenderer({canvas, antialias:false}); // antialias OFF for speed
renderer.setSize(innerWidth, innerHeight);
renderer.setPixelRatio(1); // always 1, no retina overhead
renderer.shadowMap.enabled = false; // shadows OFF â€” huge perf gain
renderer.setClearColor(0x020812);

const scene = new THREE.Scene();
scene.fog = new THREE.FogExp2(0x020818, 0.006);
const camera = new THREE.PerspectiveCamera(75, innerWidth/innerHeight, 0.1, 1200);

// â”€â”€ LIGHTING â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
scene.add(new THREE.AmbientLight(0x304060, 2.5)); // brighter ambient compensates no shadows
const sun = new THREE.DirectionalLight(0xffe0b0, 1.4);
sun.position.set(150,300,100);
scene.add(sun);

// â”€â”€ SKY + STARS â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
scene.add(new THREE.Mesh(
  new THREE.SphereGeometry(1000,16,16),
  new THREE.MeshBasicMaterial({color:0x010612,side:THREE.BackSide})
));
const sGeo=new THREE.BufferGeometry();
const sPos=new Float32Array(3000*3);
for(let i=0;i<sPos.length;i++) sPos[i]=(Math.random()-.5)*2000;
sGeo.setAttribute('position',new THREE.BufferAttribute(sPos,3));
scene.add(new THREE.Points(sGeo,new THREE.PointsMaterial({color:0xffffff,size:1.5,sizeAttenuation:true})));

// â”€â”€ SHARED GEOMETRIES (created once, reused everywhere) â”€
const GEO = {
  islandBody: new THREE.CylinderGeometry(1,1,1,10),   // scaled per island
  islandRock: new THREE.ConeGeometry(1,1,8),
  boulder:    new THREE.DodecahedronGeometry(1,0),
  trunk:      new THREE.CylinderGeometry(0.22,0.32,2.8,6),
  leaf0:      new THREE.ConeGeometry(1.6,1.6,7),
  leaf1:      new THREE.ConeGeometry(1.3,1.6,7),
  leaf2:      new THREE.ConeGeometry(1.0,1.6,7),
  bridgeSeg:  new THREE.BoxGeometry(3,0.22,1), // z-scaled per segment
  post:       new THREE.CylinderGeometry(0.08,0.08,1.5,4),
  leverBase:  new THREE.BoxGeometry(0.7,0.35,0.7),
  leverStick: new THREE.CylinderGeometry(0.1,0.1,1.3,5),
  btnBase:    new THREE.CylinderGeometry(0.45,0.45,0.22,10),
  btnTop:     new THREE.CylinderGeometry(0.32,0.32,0.18,10),
  plate:      new THREE.BoxGeometry(1.4,0.12,1.4),
  crystal:    new THREE.OctahedronGeometry(0.75,0),
  chestBase:  new THREE.BoxGeometry(1.2,0.8,0.9),
  chestLid:   new THREE.BoxGeometry(1.2,0.4,0.9),
};

// Shared static materials
const MAT = {
  rock:    new THREE.MeshLambertMaterial({color:0x554433}),
  wood:    new THREE.MeshLambertMaterial({color:0x5a3800}),
  leaf:    new THREE.MeshLambertMaterial({color:0x1a5a1a}),
  bridge:  new THREE.MeshLambertMaterial({color:0x7a5a30}),
  rope:    new THREE.MeshBasicMaterial({color:0x886633}),
  post:    new THREE.MeshBasicMaterial({color:0x886633}),
  crystal: new THREE.MeshPhongMaterial({color:0x00ccff,emissive:0x0055aa,emissiveIntensity:0.6,transparent:true,opacity:0.88,shininess:120}),
  crystalGlow: new THREE.MeshBasicMaterial({color:0x0088ff,transparent:true,opacity:0.12}),
  chestBase: new THREE.MeshLambertMaterial({color:0xaa7700}),
  chestLid:  new THREE.MeshLambertMaterial({color:0xcc9900}),
};

// â”€â”€ SEEDED RNG â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function makeRng(seed) {
  let s=(seed^0x5f3759df)>>>0;
  return ()=>{ s=(Math.imul(s,1664525)+1013904223)>>>0; return s/4294967295; };
}
function chunkHash(cx,cz) {
  return ((cx*374761393)^(cz*668265263)^(cx*cz*2246822519))>>>0;
}

// â”€â”€ WORLD CONSTANTS â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const CHUNK_SIZE    = 180;  // larger chunks = fewer chunk transitions
const LOAD_RADIUS   = 1;    // 3x3=9 chunks max
const ISLS_PER_CHUNK = 2;   // 2 islands per chunk
const BRIDGE_MAX_DIST = 250;

const loadedChunks  = new Map();
const chunkLoadQueue = [];  // async load queue
const islandList    = [];   // {group, x,y,z,r,uid,originalY}
const interactables = [];
const allCrystals   = [];
const bridgeSegs    = [];   // collision segments only (not all bridge meshes)
let colorWorldActive = false;

// â”€â”€ NUMBER LABELS â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const _nm={};
function numMat(n){
  if(_nm[n]) return _nm[n];
  const c=document.createElement('canvas'); c.width=c.height=64;
  const x=c.getContext('2d');
  x.font='bold 48px Arial'; x.textAlign='center'; x.textBaseline='middle';
  x.strokeStyle='#000'; x.lineWidth=6; x.strokeText(n,32,32);
  x.fillStyle='#ffcc00'; x.fillText(n,32,32);
  _nm[n]=new THREE.SpriteMaterial({map:new THREE.CanvasTexture(c),depthTest:false});
  return _nm[n];
}
function numSprite(n,lx,ly,lz,parent){
  const s=new THREE.Sprite(numMat(n)); s.scale.set(1.4,1.4,1.4); s.position.set(lx,ly,lz); parent.add(s);
}

// â”€â”€ TREE â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function addTree(parent,lx,lz){
  const trunk=new THREE.Mesh(GEO.trunk,MAT.wood); trunk.position.set(lx,1.4,lz); parent.add(trunk);
  const geos=[GEO.leaf0,GEO.leaf1,GEO.leaf2];
  for(let i=0;i<3;i++){const c=new THREE.Mesh(geos[i],MAT.leaf);c.position.set(lx,3.0+i*1.1,lz);parent.add(c);}
}

// â”€â”€ BUILD ISLAND â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function buildIsland(x,y,z,r,uid,rng){
  const g=new THREE.Group(); g.position.set(x,y,z);

  const bodyMat=colorWorldActive
    ? new THREE.MeshLambertMaterial({color:new THREE.Color().setHSL(Math.random(),0.7,0.45)})
    : new THREE.MeshLambertMaterial({color:new THREE.Color().setHSL(0.2+rng()*0.2,0.5,0.28)});
  const body=new THREE.Mesh(GEO.islandBody,bodyMat);
  body.scale.set(r*0.65,r*0.35,r*0.65); // scale shared geo
  g.add(body);

  const rock=new THREE.Mesh(GEO.islandRock,MAT.rock);
  rock.scale.set(r*0.72,r*0.85,r*0.72); rock.position.y=-r*0.6; g.add(rock);

  const bc=3+Math.floor(rng()*4);
  for(let i=0;i<bc;i++){
    const a=rng()*Math.PI*2,rad=rng()*r*0.42;
    const bm=new THREE.Mesh(GEO.boulder,MAT.rock);
    const s=0.4+rng()*1.2; bm.scale.setScalar(s);
    bm.position.set(Math.cos(a)*rad,r*0.18+rng()*1.2,Math.sin(a)*rad); g.add(bm);
  }
  const tc=2+Math.floor(rng()*3);
  for(let t=0;t<tc;t++){
    const a=t/tc*Math.PI*2+rng()*0.5, rad=1.8+rng()*r*0.35;
    addTree(g,Math.cos(a)*rad,Math.sin(a)*rad);
  }

  const idata={group:g,x,y,z,r,uid,originalY:y,topY:y+r*0.19};
  g.userData=idata;
  scene.add(g); islandList.push(idata);
  return idata;
}

// â”€â”€ BUILD BRIDGE â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function buildBridge(posA,posB,meshBucket){
  const dir=posB.clone().sub(posA);
  const len=dir.length(); if(len>BRIDGE_MAX_DIST||len<10) return;
  const angle=Math.atan2(dir.x,dir.z);
  const SEGS=Math.max(4,Math.floor(len/12)); // fewer segments â€” big perf gain
  const bMat=colorWorldActive
    ? new THREE.MeshLambertMaterial({color:new THREE.Color().setHSL(Math.random(),0.8,0.5)})
    : MAT.bridge; // reuse shared mat

  for(let i=0;i<SEGS;i++){
    const t0=i/SEGS,t1=(i+1)/SEGS,tm=(t0+t1)*0.5;
    const sag=t=>Math.sin(t*Math.PI)*len*0.05;
    const pmx=posA.x+dir.x*tm, pmz=posA.z+dir.z*tm;
    const pmy=posA.y+(posB.y-posA.y)*tm-sag(tm);
    const p0y=posA.y+(posB.y-posA.y)*t0-sag(t0);
    const p1y=posA.y+(posB.y-posA.y)*t1-sag(t1);
    const hL=Math.sqrt((dir.x*(t1-t0))**2+(dir.z*(t1-t0))**2);
    const segLen=Math.sqrt(hL*hL+(p1y-p0y)**2)+0.05;
    const pitch=-Math.atan2(p1y-p0y,hL);

    const seg=new THREE.Mesh(GEO.bridgeSeg,bMat);
    seg.position.set(pmx,pmy,pmz);
    seg.scale.z=segLen;
    seg.rotation.order='YXZ'; seg.rotation.y=angle; seg.rotation.x=pitch;
    scene.add(seg); meshBucket.push(seg);

    bridgeSegs.push({mesh:seg,cx:pmx,cy:pmy,cz:pmz,angle,pitch,halfLen:segLen*0.5,halfW:1.5});
    // rails every other seg
    if(i%2===0){
      for(let s=-1;s<=1;s+=2){
        const ox=Math.cos(angle+Math.PI/2)*s*1.3, oz=Math.sin(angle+Math.PI/2)*s*1.3;
        const post=new THREE.Mesh(GEO.post,MAT.post); post.position.set(pmx+ox,pmy+0.75,pmz+oz);
        scene.add(post); meshBucket.push(post);
      }
    }
  }
  // single rope each side
  for(let s=-1;s<=1;s+=2){
    const ox=Math.cos(angle+Math.PI/2)*s*1.3, oz=Math.sin(angle+Math.PI/2)*s*1.3;
    const hDir=posB.clone().sub(posA), hLen=hDir.length();
    const hMid=posA.clone().add(posB).multiplyScalar(0.5);
    hMid.y-=len*0.03;
    const rope=new THREE.Mesh(new THREE.BoxGeometry(0.07,0.07,hLen),MAT.rope);
    rope.position.set(hMid.x+ox,hMid.y+0.9,hMid.z+oz);
    rope.rotation.order='YXZ'; rope.rotation.y=angle;
    rope.rotation.x=-Math.atan2(posB.y-posA.y,hLen*0.5);
    scene.add(rope); meshBucket.push(rope);
  }
}

// â”€â”€ PUZZLE OBJECTS â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function addLever(isl,lx,lz,n,cObjs){
  const g=new THREE.Group(); g.position.set(lx,isl.r*0.19,lz);
  g.add(new THREE.Mesh(GEO.leverBase,new THREE.MeshLambertMaterial({color:0x888888})));
  const sm=new THREE.MeshLambertMaterial({color:0x888888});
  const stick=new THREE.Mesh(GEO.leverStick,sm);
  stick.position.y=0.85; stick.rotation.z=0.65; g.add(stick);
  numSprite(n,0,2.4,0,g); isl.group.add(g);
  const lp=new THREE.Vector3(lx,isl.r*0.19,lz);
  const obj={type:'lever',group:g,stick,stickMat:sm,isl,state:false,
    worldPos:()=>{const w=new THREE.Vector3();isl.group.localToWorld(w.copy(lp));return w;}};
  interactables.push(obj); cObjs.push(obj); return obj;
}
function addButton(isl,lx,lz,n,cObjs){
  const g=new THREE.Group(); g.position.set(lx,isl.r*0.19,lz);
  g.add(new THREE.Mesh(GEO.btnBase,new THREE.MeshLambertMaterial({color:0x555555})));
  const bm=new THREE.MeshLambertMaterial({color:0xff2222});
  const btn=new THREE.Mesh(GEO.btnTop,bm); btn.position.y=0.2; g.add(btn);
  numSprite(n,0,1.4,0,g); isl.group.add(g);
  const lp=new THREE.Vector3(lx,isl.r*0.19,lz);
  const obj={type:'button',group:g,btn,btnMat:bm,isl,state:false,
    worldPos:()=>{const w=new THREE.Vector3();isl.group.localToWorld(w.copy(lp));return w;}};
  interactables.push(obj); cObjs.push(obj); return obj;
}
function addPressurePlate(isl,lx,lz,n,cObjs){
  const g=new THREE.Group(); g.position.set(lx,isl.r*0.19,lz);
  const pm=new THREE.MeshLambertMaterial({color:0xddaa00});
  g.add(new THREE.Mesh(GEO.plate,pm));
  numSprite(n,0,1.3,0,g); isl.group.add(g);
  const lp=new THREE.Vector3(lx,isl.r*0.19,lz);
  const obj={type:'pressure',group:g,plateMat:pm,isl,state:false,
    worldPos:()=>{const w=new THREE.Vector3();isl.group.localToWorld(w.copy(lp));return w;}};
  interactables.push(obj); cObjs.push(obj); return obj;
}
function addCrystalAt(x,y,z,uid,cObjs){
  const g=new THREE.Group(); g.position.set(x,y,z);
  g.add(new THREE.Mesh(GEO.crystal,MAT.crystal.clone()));
  g.add(new THREE.Mesh(new THREE.SphereGeometry(1.0,6,6),MAT.crystalGlow));
  const light=new THREE.PointLight(0x0099ff,1.5,10); g.add(light);
  g.userData={isCrystal:true,collected:false,uid}; g.visible=false;
  scene.add(g); allCrystals.push(g); cObjs.push({_crystalRef:g}); return g;
}

// â”€â”€ PUZZLE CLASS â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
class Puzzle{
  constructor(steps){this.steps=steps;this.history=[];this.solved=false;this.reward=null;}
  vis(obj,on){
    if(obj.type==='lever'){obj.stick.rotation.z=on?-0.65:0.65;obj.stickMat.color.setHex(on?0x00ff88:0x888888);}
    else if(obj.type==='button'){obj.btnMat.color.setHex(on?0x00ff22:0xff2222);}
    else if(obj.type==='pressure'){obj.plateMat.color.setHex(on?0x00ff88:0xddaa00);}
  }
  tryActivate(obj){
    if(this.solved)return;
    obj.state=!obj.state; this.vis(obj,obj.state);
    if(!obj.state){const i=this.history.lastIndexOf(obj);if(i!==-1)this.history.splice(i,1);return;}
    this.history.push(obj);
    const n=this.steps.length;
    if(this.history.length>=n){
      const last=this.history.slice(-n);
      if(last.every((o,i)=>o===this.steps[i])){
        this.solved=true;this.reward.visible=true;this.reward.children[2].intensity=3;showMessage('ðŸ’Ž');
      }
    }
  }
}

// â”€â”€ GENERATE PUZZLE â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function genPuzzle(isl,rng,cObjs){
  const r=isl.r; const used=[];
  function rp(){
    for(let t=0;t<15;t++){
      const a=rng()*Math.PI*2,d=r*(0.15+rng()*0.3);
      const lx=Math.cos(a)*d,lz=Math.sin(a)*d;
      if(!used.some(p=>Math.hypot(p[0]-lx,p[1]-lz)<3.2)){used.push([lx,lz]);return[lx,lz];}
    }
    return[rng()*r*0.4-r*0.2,rng()*r*0.4-r*0.2];
  }
  const count=2+Math.floor(rng()*3);
  const positions=[]; for(let i=0;i<count;i++) positions.push(rp());
  const order=Array.from({length:count},(_,i)=>i);
  for(let i=order.length-1;i>0;i--){const j=Math.floor(rng()*(i+1));[order[i],order[j]]=[order[j],order[i]];}
  const objs=new Array(count);
  for(let i=0;i<count;i++){
    const [lx,lz]=positions[i], sn=order.indexOf(i)+1, t=Math.floor(rng()*3);
    if(t===0) objs[i]=addLever(isl,lx,lz,sn,cObjs);
    else if(t===1) objs[i]=addButton(isl,lx,lz,sn,cObjs);
    else objs[i]=addPressurePlate(isl,lx,lz,sn,cObjs);
  }
  return order.map(i=>objs[i]);
}

// â”€â”€ CHUNK SYSTEM â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function doGenerateChunk(cx,cz){
  const key=`${cx},${cz}`;
  if(loadedChunks.has(key)) return;

  const rng=makeRng(chunkHash(cx,cz));
  const isHub=(cx===0&&cz===0);
  const bx=cx*CHUNK_SIZE, bz=cz*CHUNK_SIZE;
  const islDefs=[];

  if(isHub){
    islDefs.push({x:0,y:0,z:0,r:20,uid:'hub'});
  } else {
    for(let i=0;i<ISLS_PER_CHUNK;i++){
      const a=rng()*Math.PI*2;
      const d=40+rng()*CHUNK_SIZE*0.42;
      const x=bx+Math.cos(a)*d, z=bz+Math.sin(a)*d;
      const y=(rng()-0.5)*50;
      const r=9+rng()*8;
      islDefs.push({x,y,z,r,uid:`${key}_${i}`});
    }
  }

  const builtIsls=[];
  const cObjs=[];
  const cMeshes=[];
  const cBridgeSegs=[];

  for(const def of islDefs){
    const isl=buildIsland(def.x,def.y,def.z,def.r,def.uid,rng);
    builtIsls.push(isl);
    if(def.uid!=='hub'){
      const steps=genPuzzle(isl,rng,cObjs);
      const crystal=addCrystalAt(def.x,def.y+def.r*0.19+2.5,def.z,def.uid+'_c',cObjs);
      const puz=new Puzzle(steps); puz.reward=crystal;
      steps.forEach(s=>s.puzzle=puz);
    }
  }

  // Bridges within chunk
  for(let i=0;i<builtIsls.length-1;i++){
    const a=builtIsls[i], b=builtIsls[i+1];
    const pa=new THREE.Vector3(a.x,a.y+a.r*0.19,a.z);
    const pb=new THREE.Vector3(b.x,b.y+b.r*0.19,b.z);
    buildBridge(pa,pb,cMeshes);
  }
  // One bridge to nearest island in each adjacent loaded chunk
  for(const [nk,nc] of loadedChunks){
    const [ncx,ncz]=nk.split(',').map(Number);
    if(Math.abs(ncx-cx)>1||Math.abs(ncz-cz)>1) continue;
    let bestDist=BRIDGE_MAX_DIST;
    let bestA=null,bestB=null;
    for(const myIsl of builtIsls){
      const myP=new THREE.Vector3(myIsl.x,myIsl.y+myIsl.r*0.19,myIsl.z);
      for(const nIsl of nc.isls){
        const nP=new THREE.Vector3(nIsl.x,nIsl.y+nIsl.r*0.19,nIsl.z);
        const d=myP.distanceTo(nP);
        if(d<bestDist){bestDist=d;bestA=myP;bestB=nP;}
      }
    }
    if(bestA) buildBridge(bestA,bestB,cMeshes);
  }

  loadedChunks.set(key,{islDefs,isls:builtIsls,cObjs,cMeshes,key});
}

function unloadChunk(key){
  const c=loadedChunks.get(key); if(!c) return;
  for(const isl of c.isls){
    scene.remove(isl.group);
    const i=islandList.findIndex(x=>x.uid===isl.uid); if(i!==-1) islandList.splice(i,1);
  }
  const meshSet=new Set(c.cMeshes);
  for(const m of c.cMeshes) scene.remove(m);
  for(let i=bridgeSegs.length-1;i>=0;i--){
    if(meshSet.has(bridgeSegs[i].mesh)) bridgeSegs.splice(i,1);
  }
  for(const obj of c.cObjs){
    if(obj._crystalRef){
      scene.remove(obj._crystalRef);
      const i=allCrystals.indexOf(obj._crystalRef); if(i!==-1) allCrystals.splice(i,1);
    } else {
      const i=interactables.indexOf(obj); if(i!==-1) interactables.splice(i,1);
    }
  }
  loadedChunks.delete(key);
}

let lastPCX=null,lastPCZ=null;
function queueChunkUpdates(){
  const pcx=Math.round(player.pos.x/CHUNK_SIZE);
  const pcz=Math.round(player.pos.z/CHUNK_SIZE);
  if(pcx===lastPCX&&pcz===lastPCZ) return;
  lastPCX=pcx; lastPCZ=pcz;
  // Queue new chunks
  for(let dx=-LOAD_RADIUS;dx<=LOAD_RADIUS;dx++)
    for(let dz=-LOAD_RADIUS;dz<=LOAD_RADIUS;dz++){
      const k=`${pcx+dx},${pcz+dz}`;
      if(!loadedChunks.has(k)&&!chunkLoadQueue.includes(k)) chunkLoadQueue.push(k);
    }
  // Immediately unload far chunks
  for(const key of loadedChunks.keys()){
    const [kx,kz]=key.split(',').map(Number);
    if(Math.abs(kx-pcx)>LOAD_RADIUS+1||Math.abs(kz-pcz)>LOAD_RADIUS+1) unloadChunk(key);
  }
}

function processChunkQueue(){
  // Load at most 1 chunk per frame to avoid hitching
  if(chunkLoadQueue.length===0) return;
  const key=chunkLoadQueue.shift();
  const [cx,cz]=key.split(',').map(Number);
  doGenerateChunk(cx,cz);
}

// â”€â”€ HUB + SHOP â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
doGenerateChunk(0,0);
// Queue surrounding chunks (loaded over next frames)
for(let dx=-LOAD_RADIUS;dx<=LOAD_RADIUS;dx++)
  for(let dz=-LOAD_RADIUS;dz<=LOAD_RADIUS;dz++)
    if(dx!==0||dz!==0) chunkLoadQueue.push(`${dx},${dz}`);

const hubIsl=islandList[0];
const npcGrp=new THREE.Group(); npcGrp.position.set(5,20*0.19,0);
npcGrp.add(new THREE.Mesh(GEO.chestBase,MAT.chestBase));
const chestLid=new THREE.Mesh(GEO.chestLid,MAT.chestLid); chestLid.position.y=0.6; npcGrp.add(chestLid);
const chestGlow=new THREE.Mesh(new THREE.SphereGeometry(0.9,6,6),new THREE.MeshBasicMaterial({color:0xffaa00,transparent:true,opacity:0.10}));
npcGrp.add(chestGlow);
const chestLight=new THREE.PointLight(0xffaa00,1.0,8); npcGrp.add(chestLight);
hubIsl.group.add(npcGrp);

const shopNPC={type:'shop',worldPos:()=>{const w=new THREE.Vector3();hubIsl.group.localToWorld(w.copy(new THREE.Vector3(5,20*0.19,0)));return w;}};
interactables.push(shopNPC);

function openShop(){
  document.exitPointerLock();
  document.getElementById('shop-screen').style.display='flex';
  const cb=document.getElementById('shop-color');
  if(player.collected<10||colorWorldActive){cb.classList.add('disabled');cb.querySelector('.cost').textContent=colorWorldActive?'âœ“ Gekauft':'ðŸ’Ž 10 Kristalle';}
  else cb.classList.remove('disabled');
}
function closeShop(){document.getElementById('shop-screen').style.display='none';canvas.requestPointerLock();}
function buyColor(){
  if(player.collected<10||colorWorldActive)return;
  player.collected-=10; document.getElementById('c-count').textContent=player.collected;
  colorWorldActive=true;
  for(const isl of islandList) if(isl.group.children[0]) isl.group.children[0].material=new THREE.MeshLambertMaterial({color:new THREE.Color().setHSL(Math.random(),0.7,0.45)});
  for(const seg of bridgeSegs) seg.mesh.material=new THREE.MeshLambertMaterial({color:new THREE.Color().setHSL(Math.random(),0.8,0.5)});
  closeShop(); showMessage('ðŸŒˆ Color World freigeschaltet!');
}

// â”€â”€ PLAYER â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const player={pos:new THREE.Vector3(0,8,0),vel:new THREE.Vector3(),yaw:0,pitch:0,onGround:false,collected:0};
const keys={};
window.addEventListener('keydown',e=>{keys[e.code]=true;if(e.code==='KeyE')interact();if(e.code==='Space')e.preventDefault();});
window.addEventListener('keyup',e=>{keys[e.code]=false;});
document.getElementById('start-btn').addEventListener('click',()=>{document.getElementById('start-screen').style.display='none';canvas.requestPointerLock();});
canvas.addEventListener('click',()=>{if(document.pointerLockElement!==canvas)canvas.requestPointerLock();});
window.addEventListener('mousemove',e=>{
  if(document.pointerLockElement!==canvas)return;
  player.yaw-=e.movementX*0.002; player.pitch-=e.movementY*0.002;
  player.pitch=Math.max(-1.3,Math.min(1.3,player.pitch));
});

// â”€â”€ INTERACT â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function interact(){
  const R=5;
  for(const c of allCrystals){
    if(!c.visible||c.userData.collected)continue;
    if(player.pos.distanceTo(c.position)<R-1){
      c.userData.collected=true;c.visible=false;player.collected++;
      document.getElementById('c-count').textContent=player.collected;
      showMessage('ðŸ’Ž '+player.collected); return;
    }
  }
  let nearest=null,nd=R;
  for(const obj of interactables){const d=player.pos.distanceTo(obj.worldPos());if(d<nd){nd=d;nearest=obj;}}
  if(!nearest)return;
  if(nearest.type==='shop'){openShop();return;}
  nearest.puzzle?.tryActivate(nearest);
}

// â”€â”€ PHYSICS â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const GRAVITY=-28,SPEED=13,JUMP=16;
const _pv2=new THREE.Vector3();
function physics(dt){
  const md=_pv2; md.set(0,0,0);
  if(keys['KeyW'])md.z-=1;if(keys['KeyS'])md.z+=1;
  if(keys['KeyA'])md.x-=1;if(keys['KeyD'])md.x+=1;
  if(md.lengthSq()>0)md.normalize();
  const cos=Math.cos(player.yaw),sin=Math.sin(player.yaw);
  player.vel.x=(md.x*cos+md.z*sin)*SPEED;
  player.vel.z=(-md.x*sin+md.z*cos)*SPEED;
  player.vel.y+=GRAVITY*dt;
  player.pos.addScaledVector(player.vel,dt);

  player.onGround=false;
  const px=player.pos.x,pz=player.pos.z,py=player.pos.y;

  // Island collision â€” quick distance squared check first
  for(const isl of islandList){
    const dx=px-isl.group.position.x, dz=pz-isl.group.position.z;
    const dist2=dx*dx+dz*dz;
    const r2=(isl.r*0.82)**2;
    if(dist2>r2) continue;
    const topY=isl.group.position.y+isl.r*0.19+1.7;
    if(py<topY+0.5&&py>topY-4&&player.vel.y<=0){
      player.pos.y=topY;player.vel.y=0;player.onGround=true;break;
    }
  }
  // Bridge collision â€” only check nearby segs
  if(!player.onGround&&player.vel.y<=0){
    for(const seg of bridgeSegs){
      const dx=px-seg.cx,dz=pz-seg.cz;
      if(dx*dx+dz*dz>(seg.halfLen+3)**2) continue; // quick reject
      const ca=Math.cos(-seg.angle),sa=Math.sin(-seg.angle);
      const lx=dx*ca+dz*sa,lz=-dx*sa+dz*ca;
      if(Math.abs(lx)<seg.halfW*0.92&&Math.abs(lz)<seg.halfLen+0.3){
        const sy=seg.cy+Math.tan(-seg.pitch)*lz+0.11+1.7;
        if(py<sy+0.5&&py>sy-3.5){player.pos.y=sy;player.vel.y=0;player.onGround=true;break;}
      }
    }
  }
  if(keys['Space']&&player.onGround){player.vel.y=JUMP;player.onGround=false;}
  if(py<-200){player.pos.set(0,8,0);player.vel.set(0,0,0);showMessage('ðŸ’€ Gefallen!');}
}

// â”€â”€ HINT â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const hintEl=document.getElementById('interact-hint');
function updateHint(){
  const R=5;
  let near=null;
  for(const o of interactables){if(player.pos.distanceTo(o.worldPos())<R){near=o;break;}}
  let nc=false;
  if(!near) for(const c of allCrystals){if(c.visible&&!c.userData.collected&&player.pos.distanceTo(c.position)<R-1){nc=true;break;}}
  if(near){
    hintEl.className='show';
    if(near.type==='lever')hintEl.textContent='[ E ]  Hebel betÃ¤tigen';
    else if(near.type==='button')hintEl.textContent='[ E ]  Knopf drÃ¼cken';
    else if(near.type==='pressure')hintEl.textContent='[ E ]  Druckplatte aktivieren';
    else if(near.type==='shop')hintEl.textContent='[ E ]  Shop Ã¶ffnen';
  } else if(nc){hintEl.className='show';hintEl.textContent='[ E ]  Kristall aufsammeln';}
  else hintEl.className='';
}

// â”€â”€ MESSAGE â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
let msgTimer;
function showMessage(txt){
  const el=document.getElementById('message');el.textContent=txt;el.className='show';
  clearTimeout(msgTimer);msgTimer=setTimeout(()=>el.className='',3500);
}

// â”€â”€ GAME LOOP â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
let prev=performance.now();
let frameCount=0;
function loop(now){
  requestAnimationFrame(loop);
  const dt=Math.min((now-prev)/1000,0.05);prev=now;
  const t=now/1000;
  frameCount++;

  physics(dt);

  // Process one chunk per frame (smooth loading, no hitching)
  processChunkQueue();

  // Check if player moved to new chunk (every 30 frames)
  if(frameCount%30===0) queueChunkUpdates();

  // Float islands â€” only animate nearby ones
  const px=player.pos.x,pz=player.pos.z;
  for(const isl of islandList){
    const dx=px-isl.x,dz=pz-isl.z;
    if(dx*dx+dz*dz>400*400) continue; // skip far islands
    isl.group.position.y=isl.originalY+Math.sin(t*0.35+isl.uid.length*0.7)*1.2;
  }

  // Animate visible crystals only
  for(const c of allCrystals){
    if(!c.visible)continue;
    c.children[0].rotation.y+=dt*1.8;
    c.children[0].position.y=Math.sin(t*2.2)*0.25;
  }

  // Chest
  chestGlow.material.opacity=0.07+Math.sin(t*2.5)*0.05;
  chestLight.intensity=0.9+Math.sin(t*2.5)*0.3;
  chestLid.rotation.z=Math.sin(t*1.5)*0.07;

  camera.position.copy(player.pos);
  camera.rotation.order='YXZ';camera.rotation.y=player.yaw;camera.rotation.x=player.pitch;

  if(frameCount%2===0) updateHint(); // hint only every 2 frames

  renderer.render(scene,camera);
}

window.addEventListener('resize',()=>{
  camera.aspect=innerWidth/innerHeight;camera.updateProjectionMatrix();renderer.setSize(innerWidth,innerHeight);
});
requestAnimationFrame(loop);
</script>
</body>
</html>
